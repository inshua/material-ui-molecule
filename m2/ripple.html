<!doctype html>
<html>

<head>
    <script>
        var process = {
            env: {
                NODE_ENV: 'dev'
            }
        };
        var global = window
    </script>

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <script src="../node_modules/molecule/molecule.mjs" type="module"></script>
    <meta name="import_context" value="../">
    <meta name="node_modules" value="node_modules/">
    <script src="../node_modules/classnames/index.js"></script>
    <import src="transition/index.js" tokens="{Transition}"></import>
    <import src="@material-ui-molecule/jss.js"></import>
</head>

<body>
    <template>
        <span m-def=Ripple class:x:r="$c.rippleClassName" style:o:x:r="$c.rippleStyles" 
            pulsate:b=false
            ripple-size:n=0
            ripple-y:n=0
            >
            <span class:x=$c.childClassName></span>
            <script m-class>
                willInit(){
                    this.state = {
                        visible: false,
                        leaving: false,
                    };
                    this.element.addEventListener('willenter', this.handleEnter.bind(this))
                    this.element.addEventListener('willleave', this.handleExit.bind(this))
                    super.willInit(...arguments);
                }

                handleEnter(event) {    // react 不支持 handleEnter handleExit 这么先进的东西，只能靠 Transition，搞的很复杂
                    this.setState({
                        visible: true,
                    });
                };

                handleExit(event){
                    this.setState({
                        leaving: true,
                    });
                    event.detail.addTask(new Promise((resolve, reject) => {
                        setTimeout(resolve, DURATION)
                    }));
                };

                prepareContext(){
                    const {
                        classes,
                        className: classNameProp,
                        pulsate,
                        rippleX,
                        rippleY,
                        rippleSize,
                        ...other
                        } = this.props;

                    const { visible, leaving } = this.state;

                    const rippleClassName = classNames(
                        classes.ripple,
                        {
                            [classes.rippleVisible]: visible,
                            [classes.ripplePulsate]: pulsate,
                        },
                        this.instanceProps.className
                    );

                    const rippleStyles = {
                        width: rippleSize,
                        height: rippleSize,
                        top: -(rippleSize / 2) + rippleY,
                        left: -(rippleSize / 2) + rippleX,
                    };

                    const childClassName = classNames(classes.child, {
                        [classes.childLeaving]: leaving,
                        [classes.childPulsate]: pulsate,
                    });
                    return {other, rippleClassName, rippleStyles, childClassName};
                }
            </script>
        </span>
        <script>
            const DURATION = 550;
            export const DELAY_RIPPLE = 80;

            export const styles = theme => ({
                /* Styles applied to the root element. */
                root: {
                    display: 'block',
                    position: 'absolute',
                    overflow: 'hidden',
                    borderRadius: 'inherit',
                    width: '100%',
                    height: '100%',
                    left: 0,
                    top: 0,
                    pointerEvents: 'none',
                    zIndex: 0,
                },
                /* Styles applied to the internal `Ripple` components `ripple` class. */
                ripple: {
                    width: 50,
                    height: 50,
                    left: 0,
                    top: 0,
                    opacity: 0,
                    position: 'absolute',
                },
                /* Styles applied to the internal `Ripple` components `rippleVisible` class. */
                rippleVisible: {
                    opacity: 0.3,
                    transform: 'scale(1)',
                    animation: `mui-ripple-enter ${DURATION}ms ${theme.transitions.easing.easeInOut}`,
                },
                /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */
                ripplePulsate: {
                    animationDuration: `${theme.transitions.duration.shorter}ms`,
                },
                /* Styles applied to the internal `Ripple` components `child` class. */
                child: {
                    opacity: 1,
                    display: 'block',
                    width: '100%',
                    height: '100%',
                    borderRadius: '50%',
                    backgroundColor: 'currentColor',
                },
                /* Styles applied to the internal `Ripple` components `childLeaving` class. */
                childLeaving: {
                    opacity: 0,
                    animation: `mui-ripple-exit ${DURATION}ms ${theme.transitions.easing.easeInOut}`,
                },
                /* Styles applied to the internal `Ripple` components `childPulsate` class. */
                childPulsate: {
                    position: 'absolute',
                    left: 0,
                    top: 0,
                    animation: `mui-ripple-pulsate 2500ms ${theme.transitions.easing.easeInOut} 200ms infinite`,
                },
                '@keyframes mui-ripple-enter': {
                    '0%': {
                    transform: 'scale(0)',
                    opacity: 0.1,
                    },
                    '100%': {
                    transform: 'scale(1)',
                    opacity: 0.3,
                    },
                },
                '@keyframes mui-ripple-exit': {
                    '0%': {
                    opacity: 1,
                    },
                    '100%': {
                    opacity: 0,
                    },
                },
                '@keyframes mui-ripple-pulsate': {
                    '0%': {
                    transform: 'scale(1)',
                    },
                    '50%': {
                    transform: 'scale(0.92)',
                    },
                    '100%': {
                    transform: 'scale(1)',
                    },
                },
            });
        </script>
        <span m-def=TouchRipple center:b=false class:x:r="$c.className">
            ${this.state.ripples}
            <script m-class>
                willInit(){                    
                    this.props.classes = this.attachJss(styles, 'MuiTouchRipple', 'MuiTouchRipple');
                    super.willInit(...arguments);
                }

                inited(){
                    super.inited(...arguments);
                    this.props.innerRef && this.props.innerRef(this);
                }

                constructor(){
                    super(...arguments);
                    // Used to filter out mouse emulated events on mobile.
                    this.ignoringMouseDown = false;

                    // We use a timer in order to only show the ripples for touch "click" like events.
                    // We don't want to display the ripple for touch scroll events.
                    this.startTimer = null;

                    // This is the hook called once the previous timeout is ready.
                    this.startTimerCommit = null;

                    this.state = {
                        // eslint-disable-next-line react/no-unused-state
                        nextKey: 0,
                        ripples: [],
                    };

                }
                dispose() {
                    super.dispose();
                    clearTimeout(this.startTimer);
                }

                pulsate () {
                    this.start({}, { pulsate: true });
                };

                start (event = {}, options = {}, cb) {
                    const {
                        pulsate = false,
                        center = this.props.center || options.pulsate,
                        fakeElement = false, // For test purposes
                    } = options;

                    if (event.type === 'mousedown' && this.ignoringMouseDown) {
                        this.ignoringMouseDown = false;
                        return;
                    }

                    if (event.type === 'touchstart') {
                        this.ignoringMouseDown = true;
                    }

                    const element = fakeElement ? null : this.element;
                    const rect = element
                        ? element.getBoundingClientRect()
                        : {
                            width: 0,
                            height: 0,
                            left: 0,
                            top: 0,
                        };

                    // Get the size of the ripple
                    let rippleX;
                    let rippleY;
                    let rippleSize;

                    if (
                        center ||
                        (event.clientX === 0 && event.clientY === 0) ||
                        (!event.clientX && !event.touches)
                    ) {
                        rippleX = Math.round(rect.width / 2);
                        rippleY = Math.round(rect.height / 2);
                    } else {
                        const clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                        const clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                        rippleX = Math.round(clientX - rect.left);
                        rippleY = Math.round(clientY - rect.top);
                    }

                    if (center) {
                        rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);

                        // For some reason the animation is broken on Mobile Chrome if the size if even.
                        if (rippleSize % 2 === 0) {
                        rippleSize += 1;
                        }
                    } else {
                        const sizeX =
                        Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
                        const sizeY =
                        Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
                        rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
                    }

                    // Touche devices
                    if (event.touches) {
                        // Prepare the ripple effect.
                        this.startTimerCommit = () => {
                        this.startCommit({ pulsate, rippleX, rippleY, rippleSize, cb });
                        };
                        // Deplay the execution of the ripple effect.
                        this.startTimer = setTimeout(() => {
                            if (this.startTimerCommit) {
                                this.startTimerCommit();
                                this.startTimerCommit = null;
                            }
                        }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
                    } else {
                        this.startCommit({ pulsate, rippleX, rippleY, rippleSize, cb });
                    }
                };

                startCommit(params) {
                    const { pulsate, rippleX, rippleY, rippleSize, cb } = params;

                    this.setState(state => {
                        return {
                            nextKey: state.nextKey + 1,
                            ripples: [
                                ...state.ripples,
                                {$:'span', m:'Ripple', key: state.nextKey, 
                                    props:{classes: this.props.classes, timeout: DURATION, pulsate: pulsate, 
                                            rippleX: rippleX, rippleY: rippleY, rippleSize: rippleSize}}
                            ],
                        };
                    }, cb);
                };

                stop(event, cb) {
                    clearTimeout(this.startTimer);
                    const { ripples } = this.state;

                    // The touch interaction occurs too quickly.
                    // We still want to show ripple effect.
                    if (event.type === 'touchend' && this.startTimerCommit) {
                        event.persist();
                        this.startTimerCommit();
                        this.startTimerCommit = null;
                        this.startTimer = setTimeout(() => {
                        this.stop(event, cb);
                        }, 0);
                        return;
                    }

                    this.startTimerCommit = null;

                    if (ripples && ripples.length) {
                        this.setState(
                            {
                                ripples: ripples.slice(1),
                            },
                            cb,
                        );
                    }
                };

                prepareContext() {
                    const { center, classes, className, ...other } = this.props;

                    return {className: classNames(classes.root, this.instanceProps.className), classes, other};
                }
            </script>
        </span>              

        
    </template>

    <span m=TouchRipple ripple-x=200 ripple-y=200 ripple-size=200>TouchRipple</span>
    <!-- <input value="abcd">
    <button m=mui.Button>
        CLICK ME
    </button>

    <button m=mui.Button color=primary variant="contained">
        CLICK ME
    </button> -->

    <!-- <div theme="dark" style="background: darkslategray">
        <div m=TextButtons>

        </div>
    </div>

    <div m=OutlinedButtons>

    </div>

    <div m=ContainedButtons>

    </div>

    <div m=FloatingActionButtons>

    </div>

    <div m=IconButtons>

    </div> -->

</body>
<script>
    // (async function () {
    //     console.log('add dark theme')
    //     const jss = await import ('/jslib/@material-ui-molecule/jss.js');
    //     const createMuiTheme = await import ('/jslib/@material-ui-molecule/core/styles/createMuiTheme.js');
    //     const theme = createMuiTheme.default({
    //         palette: {
    //             type: 'dark', // Switching the dark mode on is a single property value change.
    //         },
    //     });
    //     jss.themes['dark'] = theme;
    //     console.log('dark theme added')
    // })();
</script>

</html>